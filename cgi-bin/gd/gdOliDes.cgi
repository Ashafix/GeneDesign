#!/usr/bin/perl

use strict;
use CGI;
use GeneDesign;
use PML;

my $query = new CGI;
print $query->header;

my $RE_DATA = define_sites("<newenz.txt");
my $CODON_TABLE = define_codon_table(1);

my %gapperlen   = (40 => 700, 50 => 740, 60 =>740, 80 =>740, 100 => 660);
my %ungapperlen = (40 => 700, 50 => 700, 60 =>750, 80 =>680, 100 => 750);

my @styles = qw(re ol);
gdheader("Oligo Design", "gdOliDes.cgi", \@styles);

if ($query->param('TARCHNMEL') eq '')
{
	my $nucseq = $query->param('PASSNUCSEQUENCE')	?	$query->param('PASSNUCSEQUENCE')	:	$query->param('nucseq');
	my $LengChoose;
	foreach (sort keys %gapperlen)	{	$LengChoose .= ($_ == 60)	?	"<option selected value=\"$_\">$_</option>\n" . tab(6) :	"<option value=\"$_\">$_</option>\n" . tab(6);}
print <<EOM;
				<div id="notes">
					<strong>To use this module you need a nucleotide sequence at least 60bp long, a target melting temperature, and a target oligo length.</strong><br>
					Your nucleotide sequence will be searched for unique restriction sites, which will be used to divide the sequence into chunks of approximately 750bp.<br>
					If your sequence is less than 600 bp, there will only be one chunk.<br><br>
					Gapped Oligo generation seeks to create chunks of uniform overlap melting temperature; Ungapped Oligo generation seeks to create chunks of uniform oligo length.<br><br>
					<em>Please Note:</em><br>
					&nbsp;&nbsp;&bull;Chunk overlap refers to how many bp will be shared in adjacent chunks.  For instance, with a 20bp chunk overlap, if a 6bp cutter is
					 chosen as a joint it will be padded by 7bp on either side.  Those twenty bp will be in each chunk. <br>
					&nbsp;&nbsp;&bull;The melting temperature you define is the most important criteria.  Oligo lengths in practice will decrease or increase to match. <br>
					&nbsp;&nbsp;&bull;Gapped oligos are generated by default.  Uncheck "Generate Gapped Oligos" to make gapless chunks.<br>
					See the <a href="$linkpath/Guide/olides.html" target="blank">manual</a> for more information.
				</div>
				<div id="gridgroup0">Your nucleotide sequence:<br>
					<textarea name="newnucseq" rows="6" cols="100">$nucseq</textarea><br>
					Sequence name: <input type="text" name="BBNAM" value="" size="50" maxlength="50" /><br><br>
					Target Oligo Length: 
					<select name="TAROLILEN" >
						$LengChoose
					</select>bp
					&nbsp;&nbsp;&nbsp;
					Overlap Melting Temperature: <input type="text" name="TARCHNMEL" value="56" size="2" maxlength="2"/>&deg;&nbsp;&nbsp;&nbsp;
					Chunk Overlap <input type="text" name="TARCHNLAP" value="20" size="2" maxlength="2" />bp<br><br>
					Generate Gapped Oligos? <input type="checkbox" name="GAPSWIT" value="1" checked="checked" />&nbsp;&nbsp;&nbsp;<br>
					Maximum Allowable Oligo Length <input type="text" name="MAXOLILEN" value="80" size="2" maxlength="2" />bp<br><br>
					<div id="gridgroup1" align ="center" style="position:absolute; top:300; ">
						<input type="submit" name=".submit" value=" Design Oligos " />
						<input type="hidden" name="skipall" value="yes">
					</div>
				</div>
EOM
	closer();
}


elsif($query->param('newnucseq') ne '')
{
	my %pa;
	my $newnuc  = cleanup($query->param('newnucseq'), 1);
	my $aaseq   = $query->param('skipall')	?	translate($newnuc, 1, $CODON_TABLE)	:	$query->param('aaseq');	
	my $tar_chn_lap		= .5 * $query->param('TARCHNLAP');
	$pa{gapswit}		= $query->param('GAPSWIT');				#default is 1;
	$pa{tar_chn_mel}	= $query->param('TARCHNMEL');			#default is 60û
	$pa{tar_oli_len}	= $query->param('TAROLILEN');			#default is 60bp
	$pa{per_chn_len}	= $pa{gapswit} == 1			?	$gapperlen{$pa{tar_oli_len}}			:	$ungapperlen{$pa{tar_oli_len}};
	$pa{tar_oli_lap}	= $pa{gapswit} == 1			?	20										:	.5 * $pa{tar_oli_len};			# these are the defaults, 12 60mers with 20bp overlaps and 20bp gaps, nongapped oligos overlap by half the oligo length
	$pa{tar_oli_gap}	= $pa{gapswit} == 1			?	$pa{tar_oli_len}-(2*$pa{tar_oli_lap})	:	0;								# length = 2*(overlap) + gap, nongapped oligos have no gaps.
	$pa{tar_oli_num}	= ($pa{per_chn_len} - $pa{tar_oli_lap}) / ($pa{tar_oli_len} - $pa{tar_oli_lap});	# num = ( (chunk-overlap) / (length-overlap) )
	$pa{chn_mel_tol}	= 2.5;
	$pa{max_oli_len}	= $query->param('MAXOLILEN');			#default is 80bp
	$pa{melform}		= 3;
	my $nsize			= length($newnuc);	
	my $bb_name			= $query->param('BBNAM');

####PRE ERROR CHECK - pass only if sequence to be oligo-ed is an appropriate length
	if ( $nsize < 60)				#TOO SMALL FOR THIS MODULE
	{					
		take_exception("Your nucleotide sequence is only $nsize bp. A sequence of this length (less than 60bp) can be ordered as a single oligo.<br>");
	}
	elsif ($nsize > 17000)			#TOO BIG FOR GENEDESIGN
	{
		take_exception("Your nucleotide sequence is $nsize bp.  We will run out of unique restriction sites before we are able to finish this design. 
					It is recommended that you break this sequence up further yourself before oligo design.<br>");
	}
	else
	{
		my %chunk;
		my $tar_chn_len	= $pa{per_chn_len}; #this is for the magic oligo end numbers
		$tar_chn_len	= ($nsize/2) if ($nsize <= 500);	#($tar_chn_len+(.6*$tar_chn_len)));
		$tar_chn_len	= $nsize     if ($nsize < 900);		#($tar_chn_len+(.2*$tar_chn_len)));
		my $tarmult		= .96*$tar_chn_len;					#ditto
		my $limit		= int ($nsize/$tarmult)+1;
##-Figure out what the unique sites are, ignore blunts and one bp overhangs
		my $SITE_STATUS = define_site_status($newnuc, $$RE_DATA{REGEX});
		my %borders;
		foreach my $enzyme (grep {$$RE_DATA{TYPE}->{$_} !~ /b/ && $$SITE_STATUS{$_} == 1} keys %{$$RE_DATA{CLEAN}})
		{	
			my $positions = siteseeker($newnuc, $enzyme, $$RE_DATA{REGEX}->{$enzyme});
			my @temparr = keys %$positions;
			my $site = scalar(shift (@temparr)) + length($$RE_DATA{CLEAN}->{$enzyme}) + $tar_chn_lap;
			$borders{$enzyme} = $site;
		}
		my @foundsites = keys %borders;

####PRE ERROR CHECK - pass only if sequence to be oligo-ed contains a decent number of spaced unique sites
		if (scalar(keys %borders) < $limit)		#TOO FEW RESITES
		{
			take_exception("Your nucleotide sequence does not seem to contain enough unique sites.<br> 
					I can only find @foundsites.<br>There are ". scalar(keys %borders). ", and I need at least $limit.<br>
					I suggest taking this sequence through Silent Site Insertion.  An interval of 167 amino acids is usually sufficient to populate a sequence for oligo design.");
		}
		else		##-Pick sites on the target chunk interval (modular swing)
		{
			my %chosen;
			if ($nsize > ($tar_chn_len+(.2*$tar_chn_len)))
			{
				my $target = $tar_chn_len;
				my $tcv = 0;
				while ($target < ($limit*$tarmult))
				{
					my @potents = sort {abs($borders{$a}-$target) <=> abs($borders{$b}-$target)} keys %borders;
					$chosen{$potents[0]} = $borders{$potents[0]};
					$target = $target - ((2*$tar_chn_lap) + length($$RE_DATA{CLEAN}->{$potents[0]})) + $tar_chn_len;
					$tcv++;
					last if ($tar_chn_len < $pa{per_chn_len} && $tcv == 1);
					last if ($nsize - $target <= ($tar_chn_len-(.5*$tar_chn_len)));
				}
			}
			my $y = 0;
			my $start = 0;
			my @Chunks;
		##-Actually make the chunks, including the left over chunk
			foreach my $enz (sort {$chosen{$a} <=> $chosen{$b}}keys %chosen)
			{
				my $chunk = new Chunk;
				$chunk->ChunkSeq(substr($newnuc, $start, $chosen{$enz} - $start-1));
				$chunk->ChunkLength(length($chunk->ChunkSeq));
				$chunk->ChunkStart($chosen{$enz} - (2 * $tar_chn_lap) - 1 - length($$RE_DATA{CLEAN}->{$enz}));
				$chunk->ThreePrimeEnz($enz);
				$chunk->ChunkNumber($y+1);
				$chunk->Parameters(\%pa);
				$chunk->ChunkStop($chosen{$enz});
				$start = $chosen{$enz} - 2 * $tar_chn_lap - 1 - length($$RE_DATA{CLEAN}->{$enz});
				$chunk->ThreePrimeOlap($chunk->ChunkStop - $start - 1);
				push @Chunks, $chunk;
				$y++;
			}
			{	
				my $chunk = new Chunk;
				$chunk->ChunkSeq(substr($newnuc, $start));
				$chunk->ChunkLength(length($chunk->ChunkSeq));
				$chunk->ChunkStart($start);
				$chunk->ChunkNumber($y+1);
				$chunk->Parameters(\%pa);
				$chunk->ChunkStop($nsize + 1);
				push @Chunks, $chunk;
				$y++;
			}
			oligocruncher($_) foreach (@Chunks);
			
			
		##-Now for pretty output
			my @oligomain;		
			$start = 1;
{
print <<EOM;
				<div id="notes">
					Your sequence has been broken into $y chunk(s) of approximately 740bp (each).<br>
					<br><em>What am I looking at?</em><br>
					<div>
						<div style="position:absolute; width:50%;">
							<img src="$linkpath/img/olkey1.gif" align="left";>
							<-- chunk number<br>
							<-- length of chunk<br>
							<-- average Tm of oligo overlaps in chunk<br>
							<-- number of oligos in chunk<br>
							<-- average oligo length, length of shortest and longest oligos<br><br>
							<-- restriction site at 3&lsquo; end (Rebase link)<br><br>
						</div>
						<div style="position:relative; text-align: right; left:40%; width:50%;">
							<img src="$linkpath/img/olkey2.gif" align="right";>
							sense strand 5&lsquo; to 3&lsquo; --><br>
							sense (5&lsquo; to 3&lsquo;) and antisense (3&lsquo; to 5&lsquo;) oligos --><br>
							antisense strand 3&lsquo; to 5&lsquo; -->
						</div>
					</div>
					<br><br><br><br><br>
					&nbsp;&nbsp;&bull;In the table, all oligos are 5&lsquo; to 3&lsquo;.  They are output 5&lsquo; to 3&lsquo; as well.<br>
					&nbsp;&nbsp;&bull;Tm is calculated a la Primer3.<br>
					See the <a href="$linkpath/Guide/olides.html" target="blank">manual</a> for more information.
				</div>
				<div>
					<form name="form2" method="post" action="./order.cgi">
EOM
}			
			foreach my $chunk (@Chunks)
			{	
				my @oligoarr = @{$chunk->Oligos};
				my @olaparr = @{$chunk->Olaps};
				my %pa = %{$chunk->Parameters};
				if (scalar(keys %{$chunk->Collisions}) != 0)
				{
					print tab(6), "<div id = \"warn\">\n";
					print tab(7), "<strong>Warning:</strong> in the following chunk, there are ", scalar(keys %{$chunk->Collisions}), " collisions.<br>\n";
					print tab(7), "Try increasing the Tm tolerance for assembly oligos to remove collisions.\n";
					print tab(6), "</div>";
				}
print <<EOM;				
						<div id = "gridgroup0">
							<div id = "chnum">
EOM
				print tab(8), "<strong>", $chunk->ChunkNumber, "</strong><br>\n", tab(8), $chunk->ChunkLength, " bp<br>\n", tab(8),	$chunk->AvgOlapMelt, 
					"&deg;<br>\n", tab(8),	scalar(@oligoarr), "<br>\n", tab(8), $chunk->AvgOligoLength, ".", $chunk->LongOligo, ".", $chunk->ShrtOligo, "<br>";
				print "\n", tab(8), break(2*(scalar(@oligoarr)));
				print "\n", tab(8), "<a href=\"http://rebase.neb.com/rebase/enz/", $chunk->ThreePrimeEnz, ".html\" target=\"blank\">", $chunk->ThreePrimeEnz, "</a>\n", tab(7), "</div>\n";			
				print_oligos_aligned($chunk, 7);
print <<EOM;
							<br><br><br>
							<div id = "olgroup1" style = "background-color: \439AB;" width = "1000"><strong>
								<span id = "olnum">\43</span>
								<span id = "ollen">length</span>
								<span id = "olcos">start</span>
								<span id = "olcoe">stop</span>
								<span id = "olsen">sense</span>
								<span id = "ol5le">5&lsquo; overlap<br>length</span>
								<span id = "ol5me">5&lsquo; overlap<br>melt</span>
								<span id = "ol3le">3&lsquo; overlap<br>length</span>
								<span id = "ol3me">3&lsquo; overlap<br>melt</span>
								<span id = "olseq">sequence 5&lsquo; to 3&lsquo;</span>
								<br>&nbsp;</strong>
							</div>
EOM
				for my $j (0..scalar(@oligoarr)-1)
				{
					my $olnum = $j+1;
					my $ollen = length($oligoarr[$j]);
					my $olstr = $start;
					my $olend = $start + length($oligoarr[$j]) - 1;
					my $olfol = ($j == 0)					?	0				:	length($olaparr[$j-1]);
					my $oltol = ($j == scalar(@oligoarr)-1)	?	0				:	length($olaparr[$j]);
					my $olfme = ($j == 0)					?	undef			:	int(melt($olaparr[$j-1], $pa{melform}) + .5);
					my $oltme = ($j == scalar(@oligoarr)-1)	?	undef			:	int(melt($olaparr[$j], $pa{melform}) + .5);
					my $olseq = ($j % 2 == 0)				?	$oligoarr[$j]	:	complement($oligoarr[$j], 1);
					my $olsen = ($j % 2 == 0)				?	"+"				:	"-";
					($olstr, $olend) = ($olend, $olstr) if ($j % 2 == 1);
					my $color = ($j % 2)	?	"ABC"	:	"CDE"	;
print <<EOM;
							<div id = "olgroup1" style = "background-color: \43$color;">
								<span id = "olnum">$olnum</span>  
								<span id = "ollen">$ollen</span>
								<span id = "olcos">$olstr</span>
								<span id = "olcoe">$olend</span>
								<span id = "olsen">$olsen</span>
								<span id = "ol5le">$olfol</span>
								<span id = "ol5me">$olfme</span>
								<span id = "ol3le">$oltol</span>
								<span id = "ol3me">$oltme</span>
								<span id = "olseq">$olseq</span>
								&nbsp;&nbsp;<br>&nbsp;
							</div>
EOM
					$start = $start + length($oligoarr[$j]) - length($olaparr[$j]);
					push @oligomain, $olseq;
				}
				$start = $start - $chunk->ThreePrimeOlap;
print <<EOM;
						</div>
						<br><br><br>
EOM
			}
			my @aonums;
			my @bbnums;
			my @alloligos;
			foreach my $chunk (@Chunks)
			{
				my $tcv = 1;
				push @aonums, scalar(@{$chunk->Oligos});
				push @bbnums, scalar(@alloligos);
				foreach my $oligo (@{$chunk->Oligos})
				{
					my $seq = $oligo;
					$seq = complement($oligo, 1) if ($tcv % 2 == 0);
					chomp($seq);
					push @alloligos, $seq;
					$tcv++;
				}
			}
			my $banned = $query->param('banned') ?	$query->param('banned')	:	" ";
			my $hiddenhash = {"nucseq" => $newnuc, "aaseq" => $aaseq, "banned" => $banned, "MODORG" => $query->param('MODORG'), 
				"codons" => $query->param('codons'), "enzcrit" => $query->param('enzcrit'), "absentsites" => $query->param('absentsites'), 
				"vecname" => $query->param('vector'), "vecseq" => $query->param('vecseq'), "insert" => $query->param('insert'), 
				"inte" => $query->param('inte'), "actu" => $query->param('actu'), "whtemp" => $query->param('whtemp'), "TAROLILEN" => $query->param('TAROLILEN'),
				"TARCHNMEL" => $query->param('TARCHNMEL'), "TARCHNLAP" => $query->param('TARCHNLAP'), "bbnums" => join(" ", @bbnums), 
				"aonums" => join(" ", @aonums), "olarray" => join(" ", @oligomain), "alloligos" => join(" ", @alloligos)};
			my $hiddenstring = hidden_fielder($hiddenhash);
print <<EOM;
			</form>
				<form name="form2" method="post" action="./order.cgi">
				<input type="hidden" name="swit" value="2" />
				<input type="hidden" name="bbname" value="$bb_name" />
				<input type="hidden" name="startnum" value="1" />
				FASTA format: <input type="submit" value="&nbsp;Assembly Oligos&nbsp;" onClick="FASTArizer(2)" /> <br>
				tabbed format: <input type="submit" value="&nbsp;Assembly Oligos&nbsp;" onClick="FASTArizer(5)" /> <br>
				Excel file:  <input type="submit" value="&nbsp;Order Sheet&nbsp;" onClick="FASTArizer(8)" /><br>
				$hiddenstring
EOM
			closer();
		}
	}
}